[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Konstantinos Patelis",
    "section": "",
    "text": "I live in Zurich and work as a Risk Analyst with a focus on Combined Stress Testing models for the the Investment Banking division of UBS. My work revolves around modelling the evolution of the default probability of counterparties in the IB portfolio under stress scenarios and building analytical solutions to investigate core macroeconomic drivers and portfolio changes.\nOriginally from Athens, I finished my studies in Mechanical Engineering at the National Technical University of Athens, where I received my Master’s equivalent diploma in 2015. One year later I moved to Zurich to study Management and Economics at ETH and in 2017 I started working in the risk analytics space.\nI started using the R statistical language when working on my thesis at ETH to both analyse the data and apply a modeling strategy, as well as write the entire documentation. For the last couple of years, I have also been programming in Python, particularly with a focus on data manipulation and modelling. I have enjoyed using both languages in my day to day work to implement solutions that can significantly improve my team’s efficiency and productivity on our various workflows.\nOne of the purposes of this blog is to showcase tools to replace traditional software used in enterprises in order to automate common tasks and unlock potential for value creation. In fact, even this blog was built using R, Python and Quarto.\nWhen not at work or busy with other data-related projects, I enjoy watching movies and good animated shows, hiking, planning trips to new destinations with friends, playing board games with friends, and recently doing puzzles."
  },
  {
    "objectID": "about.html#hello-there",
    "href": "about.html#hello-there",
    "title": "Konstantinos Patelis",
    "section": "",
    "text": "I live in Zurich and work as a Risk Analyst with a focus on Combined Stress Testing models for the the Investment Banking division of UBS. My work revolves around modelling the evolution of the default probability of counterparties in the IB portfolio under stress scenarios and building analytical solutions to investigate core macroeconomic drivers and portfolio changes.\nOriginally from Athens, I finished my studies in Mechanical Engineering at the National Technical University of Athens, where I received my Master’s equivalent diploma in 2015. One year later I moved to Zurich to study Management and Economics at ETH and in 2017 I started working in the risk analytics space.\nI started using the R statistical language when working on my thesis at ETH to both analyse the data and apply a modeling strategy, as well as write the entire documentation. For the last couple of years, I have also been programming in Python, particularly with a focus on data manipulation and modelling. I have enjoyed using both languages in my day to day work to implement solutions that can significantly improve my team’s efficiency and productivity on our various workflows.\nOne of the purposes of this blog is to showcase tools to replace traditional software used in enterprises in order to automate common tasks and unlock potential for value creation. In fact, even this blog was built using R, Python and Quarto.\nWhen not at work or busy with other data-related projects, I enjoy watching movies and good animated shows, hiking, planning trips to new destinations with friends, playing board games with friends, and recently doing puzzles."
  },
  {
    "objectID": "project_list.html",
    "href": "project_list.html",
    "title": "Portfolio of Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\nHarlow Malloc\n\n\nJul 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nTristan O’Malley\n\n\nJul 10, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Konstantinos Patelis",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJul 10, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\n  \n\n\n\n\nClassification modeling workflow using tidymodels\n\n\n\n\n\n\n\ntidyverse\n\n\ntidymodels\n\n\nstacks\n\n\nXGBoost\n\n\n\n\n\n\n\n\n\n\n\nApr 11, 2021\n\n\nKonstantinos Patelis\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "projects/post-with-code/index.html",
    "href": "projects/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects/welcome/index.html",
    "href": "projects/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/classification-modeling-workflow-using-tidymodels/index.html",
    "href": "posts/classification-modeling-workflow-using-tidymodels/index.html",
    "title": "Classification modeling workflow using tidymodels",
    "section": "",
    "text": "A while back, I was working through the final assignment in the Practical Machine Learning Coursera course (part of the JHU Data Science Specialization), which entailed creating a model to predict the way people perform a weight-lifting exercise using data from accelerometers on the belt, forearm, arm, and dumbell of each participant. I thought this was a good opportunity to practice using the tidymodels family of packages to tackle this classification problem. So, in this post we will go through the series of steps to create our predictive model. We will cover defining the data pre-processing, specifying the model(s) to fit and using cross-validation to tune model hyperparameters. Additionally, we’ll have a look at one of the recent additions to the tidymodels packages, stacks to create an ensemble model out of our base models. We’ll see that most of our models perform almost equally well and an ensemble model is not required for achieving improved accuracy, and is presented mostly because this was a good opportunity to try it out. This blog post documents the approach taken to model this dataset."
  },
  {
    "objectID": "posts/classification-modeling-workflow-using-tidymodels/index.html#eda",
    "href": "posts/classification-modeling-workflow-using-tidymodels/index.html#eda",
    "title": "Classification modeling workflow using tidymodels",
    "section": "EDA",
    "text": "EDA\nLet’s split the initial data a training set and an test set (80/20 split). For the exploratory analysis and subsequent modeling, hyperparameter tuning and model evaluation I will use the training data set. Then the model will be used on the test data to predict out-of-sample accuracy.\n\nset.seed(1992)\n                            \nsplit &lt;- initial_split(initial_data, prop = .8, strata = classe)\n\ntrain &lt;-  training(split)\ntest &lt;- testing(split)\n\nskim(train)\n\n\nData summary\n\n\nName\ntrain\n\n\nNumber of rows\n15695\n\n\nNumber of columns\n159\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n105\n\n\nnumeric\n53\n\n\nPOSIXct\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nuser_name\n0\n1.00\n5\n8\n0\n6\n0\n\n\nraw_timestamp_part_1\n0\n1.00\n10\n10\n0\n837\n0\n\n\nraw_timestamp_part_2\n0\n1.00\n3\n6\n0\n13803\n0\n\n\nnew_window\n0\n1.00\n2\n3\n0\n2\n0\n\n\nkurtosis_roll_belt\n15382\n0.02\n7\n9\n0\n306\n0\n\n\nkurtosis_picth_belt\n15382\n0.02\n7\n9\n0\n260\n0\n\n\nkurtosis_yaw_belt\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nskewness_roll_belt\n15382\n0.02\n7\n9\n0\n304\n0\n\n\nskewness_roll_belt.1\n15382\n0.02\n7\n9\n0\n271\n0\n\n\nskewness_yaw_belt\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nmax_roll_belt\n15382\n0.02\n1\n5\n0\n165\n0\n\n\nmax_picth_belt\n15382\n0.02\n1\n2\n0\n20\n0\n\n\nmax_yaw_belt\n15382\n0.02\n3\n7\n0\n59\n0\n\n\nmin_roll_belt\n15382\n0.02\n2\n5\n0\n162\n0\n\n\nmin_pitch_belt\n15382\n0.02\n1\n2\n0\n15\n0\n\n\nmin_yaw_belt\n15382\n0.02\n3\n7\n0\n59\n0\n\n\namplitude_roll_belt\n15382\n0.02\n1\n5\n0\n125\n0\n\n\namplitude_pitch_belt\n15382\n0.02\n1\n2\n0\n13\n0\n\n\namplitude_yaw_belt\n15382\n0.02\n4\n7\n0\n3\n0\n\n\nvar_total_accel_belt\n15382\n0.02\n1\n6\n0\n57\n0\n\n\navg_roll_belt\n15382\n0.02\n1\n8\n0\n159\n0\n\n\nstddev_roll_belt\n15382\n0.02\n1\n6\n0\n61\n0\n\n\nvar_roll_belt\n15382\n0.02\n1\n7\n0\n80\n0\n\n\navg_pitch_belt\n15382\n0.02\n1\n8\n0\n182\n0\n\n\nstddev_pitch_belt\n15382\n0.02\n1\n6\n0\n39\n0\n\n\nvar_pitch_belt\n15382\n0.02\n1\n6\n0\n55\n0\n\n\navg_yaw_belt\n15382\n0.02\n1\n8\n0\n203\n0\n\n\nstddev_yaw_belt\n15382\n0.02\n1\n6\n0\n53\n0\n\n\nvar_yaw_belt\n15382\n0.02\n1\n8\n0\n127\n0\n\n\nvar_accel_arm\n15382\n0.02\n1\n8\n0\n308\n0\n\n\navg_roll_arm\n15382\n0.02\n1\n9\n0\n255\n0\n\n\nstddev_roll_arm\n15382\n0.02\n1\n8\n0\n255\n0\n\n\nvar_roll_arm\n15382\n0.02\n1\n10\n0\n255\n0\n\n\navg_pitch_arm\n15382\n0.02\n1\n8\n0\n255\n0\n\n\nstddev_pitch_arm\n15382\n0.02\n1\n7\n0\n255\n0\n\n\nvar_pitch_arm\n15382\n0.02\n1\n9\n0\n255\n0\n\n\navg_yaw_arm\n15382\n0.02\n1\n9\n0\n255\n0\n\n\nstddev_yaw_arm\n15382\n0.02\n1\n8\n0\n254\n0\n\n\nvar_yaw_arm\n15382\n0.02\n1\n10\n0\n254\n0\n\n\nkurtosis_roll_arm\n15382\n0.02\n7\n8\n0\n254\n0\n\n\nkurtosis_picth_arm\n15382\n0.02\n7\n8\n0\n254\n0\n\n\nkurtosis_yaw_arm\n15382\n0.02\n7\n8\n0\n308\n0\n\n\nskewness_roll_arm\n15382\n0.02\n7\n8\n0\n255\n0\n\n\nskewness_pitch_arm\n15382\n0.02\n7\n8\n0\n254\n0\n\n\nskewness_yaw_arm\n15382\n0.02\n7\n8\n0\n307\n0\n\n\nmax_roll_arm\n15382\n0.02\n1\n5\n0\n234\n0\n\n\nmax_picth_arm\n15382\n0.02\n1\n5\n0\n209\n0\n\n\nmax_yaw_arm\n15382\n0.02\n1\n2\n0\n51\n0\n\n\nmin_roll_arm\n15382\n0.02\n1\n5\n0\n222\n0\n\n\nmin_pitch_arm\n15382\n0.02\n1\n5\n0\n233\n0\n\n\nmin_yaw_arm\n15382\n0.02\n1\n2\n0\n38\n0\n\n\namplitude_roll_arm\n15382\n0.02\n1\n5\n0\n242\n0\n\n\namplitude_pitch_arm\n15382\n0.02\n1\n6\n0\n233\n0\n\n\namplitude_yaw_arm\n15382\n0.02\n1\n2\n0\n51\n0\n\n\nkurtosis_roll_dumbbell\n15382\n0.02\n6\n7\n0\n305\n0\n\n\nkurtosis_picth_dumbbell\n15382\n0.02\n6\n7\n0\n310\n0\n\n\nkurtosis_yaw_dumbbell\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nskewness_roll_dumbbell\n15382\n0.02\n6\n7\n0\n310\n0\n\n\nskewness_pitch_dumbbell\n15382\n0.02\n6\n7\n0\n309\n0\n\n\nskewness_yaw_dumbbell\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nmax_roll_dumbbell\n15382\n0.02\n1\n5\n0\n270\n0\n\n\nmax_picth_dumbbell\n15382\n0.02\n2\n6\n0\n277\n0\n\n\nmax_yaw_dumbbell\n15382\n0.02\n3\n7\n0\n66\n0\n\n\nmin_roll_dumbbell\n15382\n0.02\n1\n6\n0\n274\n0\n\n\nmin_pitch_dumbbell\n15382\n0.02\n1\n6\n0\n277\n0\n\n\nmin_yaw_dumbbell\n15382\n0.02\n3\n7\n0\n66\n0\n\n\namplitude_roll_dumbbell\n15382\n0.02\n1\n6\n0\n298\n0\n\n\namplitude_pitch_dumbbell\n15382\n0.02\n1\n6\n0\n295\n0\n\n\namplitude_yaw_dumbbell\n15382\n0.02\n4\n7\n0\n2\n0\n\n\nvar_accel_dumbbell\n15382\n0.02\n1\n8\n0\n296\n0\n\n\navg_roll_dumbbell\n15382\n0.02\n5\n9\n0\n307\n0\n\n\nstddev_roll_dumbbell\n15382\n0.02\n1\n8\n0\n301\n0\n\n\nvar_roll_dumbbell\n15382\n0.02\n1\n10\n0\n301\n0\n\n\navg_pitch_dumbbell\n15382\n0.02\n5\n8\n0\n307\n0\n\n\nstddev_pitch_dumbbell\n15382\n0.02\n1\n7\n0\n301\n0\n\n\nvar_pitch_dumbbell\n15382\n0.02\n1\n9\n0\n301\n0\n\n\navg_yaw_dumbbell\n15382\n0.02\n5\n9\n0\n307\n0\n\n\nstddev_yaw_dumbbell\n15382\n0.02\n1\n7\n0\n301\n0\n\n\nvar_yaw_dumbbell\n15382\n0.02\n1\n9\n0\n301\n0\n\n\nkurtosis_roll_forearm\n15382\n0.02\n6\n7\n0\n245\n0\n\n\nkurtosis_picth_forearm\n15382\n0.02\n6\n7\n0\n245\n0\n\n\nkurtosis_yaw_forearm\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nskewness_roll_forearm\n15382\n0.02\n6\n7\n0\n246\n0\n\n\nskewness_pitch_forearm\n15382\n0.02\n6\n7\n0\n241\n0\n\n\nskewness_yaw_forearm\n15382\n0.02\n7\n7\n0\n1\n0\n\n\nmax_roll_forearm\n15382\n0.02\n1\n5\n0\n220\n0\n\n\nmax_picth_forearm\n15382\n0.02\n1\n5\n0\n123\n0\n\n\nmax_yaw_forearm\n15382\n0.02\n3\n7\n0\n43\n0\n\n\nmin_roll_forearm\n15382\n0.02\n1\n5\n0\n213\n0\n\n\nmin_pitch_forearm\n15382\n0.02\n1\n5\n0\n139\n0\n\n\nmin_yaw_forearm\n15382\n0.02\n3\n7\n0\n43\n0\n\n\namplitude_roll_forearm\n15382\n0.02\n1\n5\n0\n229\n0\n\n\namplitude_pitch_forearm\n15382\n0.02\n1\n6\n0\n144\n0\n\n\namplitude_yaw_forearm\n15382\n0.02\n4\n7\n0\n2\n0\n\n\nvar_accel_forearm\n15382\n0.02\n1\n9\n0\n310\n0\n\n\navg_roll_forearm\n15382\n0.02\n1\n10\n0\n245\n0\n\n\nstddev_roll_forearm\n15382\n0.02\n1\n9\n0\n243\n0\n\n\nvar_roll_forearm\n15382\n0.02\n1\n11\n0\n243\n0\n\n\navg_pitch_forearm\n15382\n0.02\n1\n9\n0\n247\n0\n\n\nstddev_pitch_forearm\n15382\n0.02\n1\n8\n0\n247\n0\n\n\nvar_pitch_forearm\n15382\n0.02\n1\n10\n0\n247\n0\n\n\navg_yaw_forearm\n15382\n0.02\n1\n10\n0\n247\n0\n\n\nstddev_yaw_forearm\n15382\n0.02\n1\n9\n0\n245\n0\n\n\nvar_yaw_forearm\n15382\n0.02\n1\n11\n0\n245\n0\n\n\nclasse\n0\n1.00\n1\n1\n0\n5\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nnum_window\n0\n1\n432.51\n248.50\n1.00\n223.00\n427.00\n648.00\n864.00\n▇▇▇▇▇\n\n\nroll_belt\n0\n1\n64.69\n62.73\n-28.90\n1.10\n114.00\n123.00\n162.00\n▇▁▁▅▅\n\n\npitch_belt\n0\n1\n0.18\n22.45\n-55.80\n1.67\n5.27\n14.90\n60.30\n▃▁▇▅▁\n\n\nyaw_belt\n0\n1\n-10.74\n95.50\n-180.00\n-88.30\n-12.30\n13.70\n179.00\n▁▇▅▁▃\n\n\ntotal_accel_belt\n0\n1\n11.34\n7.74\n0.00\n3.00\n17.00\n18.00\n29.00\n▇▁▂▆▁\n\n\ngyros_belt_x\n0\n1\n-0.01\n0.21\n-1.00\n-0.03\n0.03\n0.11\n2.22\n▁▇▁▁▁\n\n\ngyros_belt_y\n0\n1\n0.04\n0.08\n-0.53\n0.00\n0.02\n0.11\n0.64\n▁▁▇▁▁\n\n\ngyros_belt_z\n0\n1\n-0.13\n0.24\n-1.46\n-0.20\n-0.10\n-0.02\n1.62\n▁▂▇▁▁\n\n\naccel_belt_x\n0\n1\n-5.41\n29.74\n-120.00\n-21.00\n-14.00\n-5.00\n83.00\n▁▁▇▁▂\n\n\naccel_belt_y\n0\n1\n30.26\n28.52\n-65.00\n3.00\n36.00\n61.00\n164.00\n▁▇▇▁▁\n\n\naccel_belt_z\n0\n1\n-73.05\n100.39\n-275.00\n-162.00\n-153.00\n27.00\n104.00\n▁▇▁▅▃\n\n\nmagnet_belt_x\n0\n1\n55.98\n64.44\n-52.00\n9.00\n35.00\n60.00\n485.00\n▇▁▂▁▁\n\n\nmagnet_belt_y\n0\n1\n593.68\n35.62\n354.00\n581.00\n601.00\n610.00\n673.00\n▁▁▁▇▃\n\n\nmagnet_belt_z\n0\n1\n-345.54\n65.02\n-623.00\n-375.00\n-320.00\n-306.00\n293.00\n▁▇▁▁▁\n\n\nroll_arm\n0\n1\n18.22\n72.38\n-180.00\n-31.20\n0.00\n77.20\n180.00\n▁▃▇▆▂\n\n\npitch_arm\n0\n1\n-4.61\n30.75\n-88.20\n-25.70\n0.00\n11.20\n88.50\n▁▅▇▂▁\n\n\nyaw_arm\n0\n1\n-0.50\n71.12\n-180.00\n-42.70\n0.00\n45.60\n180.00\n▁▃▇▃▂\n\n\ntotal_accel_arm\n0\n1\n25.44\n10.53\n1.00\n17.00\n27.00\n33.00\n66.00\n▃▆▇▁▁\n\n\ngyros_arm_x\n0\n1\n0.04\n1.99\n-6.37\n-1.35\n0.08\n1.56\n4.87\n▁▃▇▆▂\n\n\ngyros_arm_y\n0\n1\n-0.26\n0.85\n-3.44\n-0.80\n-0.24\n0.14\n2.81\n▁▂▇▂▁\n\n\ngyros_arm_z\n0\n1\n0.27\n0.55\n-2.33\n-0.07\n0.25\n0.72\n3.02\n▁▂▇▂▁\n\n\naccel_arm_x\n0\n1\n-60.27\n181.43\n-404.00\n-241.00\n-43.00\n83.00\n435.00\n▆▆▇▅▁\n\n\naccel_arm_y\n0\n1\n32.11\n109.77\n-315.00\n-54.00\n13.00\n139.00\n308.00\n▁▃▇▆▂\n\n\naccel_arm_z\n0\n1\n-70.98\n134.52\n-636.00\n-142.00\n-47.00\n23.00\n271.00\n▁▁▅▇▁\n\n\nmagnet_arm_x\n0\n1\n191.39\n443.76\n-584.00\n-299.00\n284.00\n638.00\n780.00\n▆▃▂▃▇\n\n\nmagnet_arm_y\n0\n1\n156.45\n202.35\n-392.00\n-10.00\n202.00\n323.00\n583.00\n▁▅▅▇▂\n\n\nmagnet_arm_z\n0\n1\n306.97\n326.20\n-597.00\n133.00\n443.00\n545.00\n694.00\n▁▂▂▃▇\n\n\nroll_dumbbell\n0\n1\n24.01\n69.84\n-153.51\n-17.42\n48.42\n67.58\n153.55\n▂▂▃▇▂\n\n\npitch_dumbbell\n0\n1\n-10.79\n36.94\n-149.59\n-40.69\n-21.10\n17.64\n149.40\n▁▆▇▂▁\n\n\nyaw_dumbbell\n0\n1\n1.48\n82.56\n-150.87\n-77.75\n-4.16\n79.97\n154.75\n▃▇▅▅▆\n\n\ntotal_accel_dumbbell\n0\n1\n13.71\n10.21\n0.00\n4.00\n10.00\n19.00\n42.00\n▇▅▃▃▁\n\n\ngyros_dumbbell_x\n0\n1\n0.17\n0.39\n-1.99\n-0.03\n0.13\n0.35\n2.20\n▁▁▇▁▁\n\n\ngyros_dumbbell_y\n0\n1\n0.04\n0.48\n-2.10\n-0.14\n0.05\n0.21\n4.37\n▁▇▁▁▁\n\n\ngyros_dumbbell_z\n0\n1\n-0.15\n0.32\n-2.38\n-0.31\n-0.13\n0.03\n1.72\n▁▁▇▂▁\n\n\naccel_dumbbell_x\n0\n1\n-28.62\n67.02\n-237.00\n-50.00\n-8.00\n11.00\n235.00\n▁▂▇▁▁\n\n\naccel_dumbbell_y\n0\n1\n52.77\n80.36\n-189.00\n-8.00\n42.00\n111.00\n302.00\n▁▇▇▅▁\n\n\naccel_dumbbell_z\n0\n1\n-38.32\n109.57\n-334.00\n-141.00\n-1.00\n38.00\n318.00\n▁▆▇▃▁\n\n\nmagnet_dumbbell_x\n0\n1\n-329.18\n340.01\n-643.00\n-535.00\n-480.00\n-306.00\n592.00\n▇▂▁▁▂\n\n\nmagnet_dumbbell_y\n0\n1\n220.95\n326.12\n-3600.00\n232.00\n311.00\n389.00\n633.00\n▁▁▁▁▇\n\n\nmagnet_dumbbell_z\n0\n1\n46.05\n140.02\n-262.00\n-45.00\n14.00\n95.00\n452.00\n▁▇▆▂▂\n\n\nroll_forearm\n0\n1\n33.82\n107.89\n-180.00\n-0.66\n21.20\n140.00\n180.00\n▃▂▇▂▇\n\n\npitch_forearm\n0\n1\n10.67\n27.97\n-72.50\n0.00\n9.19\n28.40\n89.80\n▁▁▇▃▁\n\n\nyaw_forearm\n0\n1\n19.76\n103.09\n-180.00\n-68.00\n0.00\n110.00\n180.00\n▅▅▇▆▇\n\n\ntotal_accel_forearm\n0\n1\n34.77\n10.06\n0.00\n29.00\n36.00\n41.00\n79.00\n▁▃▇▁▁\n\n\ngyros_forearm_x\n0\n1\n0.16\n0.63\n-4.95\n-0.21\n0.05\n0.58\n3.97\n▁▁▇▃▁\n\n\ngyros_forearm_y\n0\n1\n0.06\n2.17\n-7.02\n-1.48\n0.03\n1.62\n6.13\n▁▃▇▆▁\n\n\ngyros_forearm_z\n0\n1\n0.14\n0.60\n-8.09\n-0.18\n0.08\n0.49\n4.10\n▁▁▁▇▁\n\n\naccel_forearm_x\n0\n1\n-62.55\n180.36\n-498.00\n-179.00\n-57.00\n75.00\n477.00\n▂▆▇▅▁\n\n\naccel_forearm_y\n0\n1\n164.76\n200.25\n-632.00\n57.00\n201.00\n313.00\n591.00\n▁▂▃▇▃\n\n\naccel_forearm_z\n0\n1\n-54.99\n138.27\n-446.00\n-181.00\n-39.00\n26.00\n291.00\n▁▇▅▅▃\n\n\nmagnet_forearm_x\n0\n1\n-314.94\n345.59\n-1280.00\n-617.00\n-382.00\n-78.00\n666.00\n▁▇▇▅▁\n\n\nmagnet_forearm_y\n0\n1\n382.40\n508.76\n-896.00\n8.50\n593.00\n738.00\n1480.00\n▂▂▂▇▁\n\n\nmagnet_forearm_z\n0\n1\n393.79\n369.52\n-973.00\n193.00\n511.00\n653.00\n1090.00\n▁▁▂▇▃\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ncvtd_timestamp\n0\n1\n2011-11-28 14:13:00\n2011-12-05 14:24:00\n2011-12-02 13:35:00\n20\n\n\n\n\n\nIt seems like the majority of the variables are numeric, but one important thing to note is that there is a high percentage of missing observations for a subset of the variables. From the completion rate, it seems that the missing values across the different attributes occur for the same observations. Since the majority of observations have missing values for these variables, it is unlikely that we could impute them. When viewing the data in spreadsheet applications these variables have a mix of being coded as NA or being simply blank, while even for observations where values are available, there are instances of a value showing as #DIV/0.\n\neda &lt;- train %&gt;% select(where(~ !any(is.na(.))))\n\nOne important thing in classification problems is to investigate whether there is imbalance between the different classes in our training data. For example, if a class is over-represented in the data then our classifier might tend to over-predict that class. Let’s check how many times each class appears in the data.\n\nggplot(eda, aes(classe, fill = classe)) + \n  geom_bar() + \n  theme_bw()\n\n\n\n\nLooking at the above, there does not seem to be severe imbalance among classes. The first class, A is represented more compared to the other ones, but it’s not to an overwhelming extent.\nConsidering the other columns in our data, user name cannot be part of our predictors because it cannot generalize to other data if our model was used on data that is not part of this study. Looking at the timestamp, each subject was fully measured at a different point in the day, with each exercise happening back-to-back. From Velloso et al. (2013) (Velloso et al. 2013), we know that all subjects were observed in the presence of a professional trainer to observe that the exercise was done according to specification each time. I will not consider the timestamps or any features derived from them (e.g. using the time of day) as a predictor in our models.\n\neda %&gt;% \n  mutate(new_window = as.numeric(factor(new_window))) %&gt;% \n  select(where(is.numeric)) %&gt;% \n  correlate(method = \"pearson\", quiet = TRUE) %&gt;% \n  shave() %&gt;% \n  rplot() %&gt;% \n  ggplotly()\n\n\n\n\n\n\nYou can highlight a circle to see the values for which that correlation was calculated, since it’s not easy to make it out from the axes.\n\nEven excluding the columns mentioned above, there are a lot of features and presenting more information on EDA here would get too extensive. Since the purpose here is to demonstrate the modeling process with tidymodels, we will not be performing a more extensive EDA. For quick data exploration, you can use DataExplorer::create_report(eda) and explore::explore(eda) (after installing the two packages) to get a full data report on the data set from the former and a shiny app for interactive exploration from the latter."
  },
  {
    "objectID": "posts/classification-modeling-workflow-using-tidymodels/index.html#modeling",
    "href": "posts/classification-modeling-workflow-using-tidymodels/index.html#modeling",
    "title": "Classification modeling workflow using tidymodels",
    "section": "Modeling",
    "text": "Modeling\nIn this section we will define the recipe to pre-process the data, specify the models and combine these steps in a workflow. Then we will use cross-validation to tune the various hyper-parameters of the models.\n\nPre-processing Recipe\nI will use the recipes package to provide a specification of all the transformations to the data set before I fit any models, which will ensure that the same transformations are applied to the training, test and quiz data in the same way. Furthermore, it helps avoid information leakage as the transformations will be applied to all data sets using the statistics calculated for the training data. Specifically, I will remove all variables with missing values as well as other attributes discussed above, perform a transformation to try to make all predictors more symmetric (which is useful for models that benefit from predictors with distributions close to the Gaussian), normalize all variables (particularly important for the KNN and glmnet models) and then removing any predictors, if any, with very small variance. Note that we could define different pre-processing steps if required by the various models we will be tuning.\n\n# Creating a vector with the names of all variables that should be removed because they contain NAs\n\ncols_rm &lt;- train %&gt;% \n  select(where(~ any(is.na(.)))) %&gt;% \n  colnames()\n\nmodel_recipe &lt;- recipe(classe ~ ., data = train) %&gt;% \n  step_rm(all_of(!!cols_rm), all_nominal(), -all_outcomes(), \n          cvtd_timestamp, num_window, \n          new_window) %&gt;% \n  step_YeoJohnson(all_predictors()) %&gt;% \n  step_normalize(all_predictors()) %&gt;% \n  step_nzv(all_predictors())\n\n# Below rows can be used to perform the transformation on the training set. Since we will be using the workflow package, this is not required.\n\n# model_recipe_prepped &lt;- model_recipe %&gt;% prep()\n# baked_recipe &lt;- model_recipe_prepped %&gt;% bake(new_data = NULL)\n\n\n\nModel Specification\nIn this section I will use the parsnip package to create model specifications and set which model parameters will need to be tuned to ensure higher model performance. I will be trying four different models:\n\nRandom Forests (rf) - with 1000 trees and we will tune the number of predictors at each node split and the minimum number of data points in a node required for the node to be further split.\nK Nearest Neighbours (knn) - with a tunable number k of neighbours, kernel function with which to weight distances, and the parameter for the Minkowski distance.\nMultinomial Logistic Regression with Regularization (lm) - with a tunable regularization penalty.\nBoosted Trees (boost) - where we tune the number of trees, the learning rate, tree depth, number of predictors at each node split and the minimum number of data points in a node.\n\nI will then use the workflows package to combine the model recipe and the model specifications into different workflows. With parsnip we can create the specification in a similar manner across models and specify “computational engines” - practically R functions/packages that implement the calculations.\n\nrf_model &lt;- rand_forest(\n                        mtry = tune(),\n                        min_n = tune(),\n                        trees = 1000\n                        ) %&gt;% \n            set_engine(\"ranger\") %&gt;% \n            set_mode(\"classification\")\n            \n\n# rf_fit &lt;- fit(rf_model, classe ~ ., data = baked_recipe) # This call could be used to fit the model to the training data, but we will be using the workflows interface\n\nknn_model &lt;- nearest_neighbor(\n                              neighbors = tune(), \n                              weight_func = tune(), \n                              dist_power = tune()\n                              ) %&gt;% \n             set_engine(\"kknn\") %&gt;% \n             set_mode(\"classification\")\n\n# knn_fit &lt;- fit(knn_model, classe ~ ., data = baked_recipe)\n\nlasso_model &lt;- multinom_reg(\n                             penalty = tune(),\n                             mixture = 1\n                             ) %&gt;% \n                set_engine(\"glmnet\")\n\n# lasso_fit &lt;- fit(lasso_model, classe ~ ., data = baked_recipe)\n\nboost_model &lt;- boost_tree(\n                          trees = tune(), \n                          mtry = tune(),\n                          min_n = tune(),\n                          learn_rate = tune(),\n                          tree_depth = tune()\n                          ) %&gt;% \n               set_engine(\"xgboost\") %&gt;% \n               set_mode(\"classification\")\n\n# boost_fit &lt;- fit(boost_model, classe ~ ., data = baked_recipe)\n\n\n# Combine the model and the pre-processing recipe in a workflow (per each model)\n\nrf_wf &lt;- workflow() %&gt;% \n  add_model(rf_model) %&gt;% \n  add_recipe(model_recipe)\n\nknn_wf &lt;- workflow() %&gt;% \n  add_model(knn_model) %&gt;% \n  add_recipe(model_recipe)\n\nlasso_wf &lt;- workflow() %&gt;% \n  add_model(lasso_model) %&gt;% \n  add_recipe(model_recipe)\n\nboost_wf &lt;- workflow() %&gt;% \n  add_model(boost_model) %&gt;% \n  add_recipe(model_recipe)\n\n\n\nModel Tuning\nLet us tune the different model parameters using 10-fold cross-validation. To create the grid with the combinations of parameters we can use a space-filling design with 30 points, based on which 30 combinations of the parameters will be picked such that they cover the most area in the design space. The dials package contains sensible default ranges for the most common hyperparameters that are tuned in models. The user can modify those if required, and for some, the default range depends on the number of features. One such example is the mtry parameter in random forests and boosted trees algorithms, whose max value is equal to the number of predictors in the processed data set. If the number of predictors is known, we can use the finalize function to assign the range for mtry. This would not be possible if our model recipe contained steps that tune the final number of predictors (e.g. pre-processing with PCA and tuning the number of components to keep).\n\n# Extract the parameters that require tuning to pass into the tuning grid\n\ntrained_data &lt;- model_recipe %&gt;% prep() %&gt;% bake(new_data = NULL)\n\nrf_param &lt;- extract_parameter_set_dials(rf_wf) %&gt;% finalize(trained_data) # This was updated in December of 2023 to replace now deprecated parameters() function with extract_parameter_set_dials()\nknn_param &lt;- extract_parameter_set_dials(knn_wf) \nlasso_param &lt;- extract_parameter_set_dials(lasso_wf)\nboost_param &lt;- extract_parameter_set_dials(boost_wf) %&gt;% finalize(trained_data)\n\nrf_param %&gt;% extract_parameter_dials(\"mtry\") # This was updated in December of 2023 to replace now deprecated pull_dials_object() function with extract_parameter_dials()\n\n# Randomly Selected Predictors (quantitative)\nRange: [1, 53]\n\n\nWhen tuning a model, it is always important to consider what we are trying to optimize the model (e.g. achieve highest possible accuracy, maximize true positives, etc). For our problem, the aim is to accurately predict the class of each observation, so at the end of the tuning process we will pick the hyperparameters that achieve highest accuracy. When tuning classification models with the tune package, by default the accuracy and area under the ROC curve are calculated for each fold. We can specify other metrics from the yardstick package to calculate while tuning by specifying the metrics parameter e.g. in tune_grid. Note that if the metrics specified perform hard class predictions (if we selected accuracy as our sole metric), then classification probabilities are not created. Since these are required for our ensemble model in a later section, we’ll also calculate the area under the curve to get the probabilities.\n\n# Split the train set into folds\n\nset.seed(9876)\n\nfolds &lt;- vfold_cv(data = train, v = 10, strata = \"classe\")\n\n# requires the doParallel package to fit resamples in parallel\n\ncl &lt;- makePSOCKcluster(10) # select the number of cores to parallelize the calcs across\nregisterDoParallel(cl)\n\nset.seed(753)\n\nrf_tune &lt;- rf_wf %&gt;%\n  tune_grid(\n    folds,\n    grid = 30,\n    param_info = rf_param,\n    control = control_grid(\n      verbose = TRUE,\n      allow_par = TRUE,\n      save_pred = TRUE,\n      save_workflow = TRUE,\n      parallel_over = \"resamples\"\n    )\n  )\n\n# 3423.57 sec elapsed\n\nset.seed(456)\n\nknn_tune &lt;- knn_wf %&gt;%\n  tune_grid(\n    folds,\n    grid = 30,\n    param_info = knn_param,\n    control = control_grid(\n      verbose = TRUE,\n      allow_par = TRUE,\n      save_pred = TRUE,\n      save_workflow = TRUE,\n      parallel_over = \"resamples\"\n    )\n  )\n\n# 8419.63 sec elapsed\n\nlasso_tune &lt;- lasso_wf %&gt;%\n  tune_grid(\n    folds,\n    grid = 30,\n    param_info = lasso_param,\n    control = control_grid(\n      verbose = TRUE,\n      allow_par = TRUE,\n      save_pred = TRUE,\n      save_workflow = TRUE,\n      parallel_over = \"resamples\"\n    )\n  )\n\nset.seed(1821)\n\nboost_tune &lt;- boost_wf %&gt;%\n  tune_grid(\n    folds,\n    grid = 30,\n    param_info = boost_param,\n    control = control_grid(\n      verbose = TRUE,\n      allow_par = TRUE,\n      save_pred = TRUE,\n      save_workflow = TRUE,\n      parallel_over = \"resamples\"\n    )\n  )\n\nstopCluster(cl)\n\n\n\nIn-sample Accuracy\nOne can use the collect_metrics() function to each of these to visualize the average accuracy for each combination of parameters (averaging across resamples), and see the various hyperparameters that achieve such accuracy.\n\nautoplot(rf_tune, metric = \"accuracy\")\n\nWe can see that for the random forests model a combination of around 15-20 predictors and a minimal node size in the range between 5-15 seem to be optimal.\n\nautoplot(knn_tune, metric = \"accuracy\")\n\nFor K-NN, a small number of neighbours is preferred, while Minkowski Distance of order 0.25 seems to perform best.\n\nautoplot(lasso_tune, metric = \"accuracy\")\n\nSmall penalty is preferred for the LASSO model and it seems that up to a point, similar accuracy levels are achieved.\n\nautoplot(boost_tune, metric = \"accuracy\")\n\nFor boosted trees, it seems that a higher learning rate is better. Higher tree depth (especially in the range of 9-14) seems to provide best results, while the number of trees and the minimal node size seem to have a wide range of values for which we achieve increased accuracy.\nLet us select the best models from each type of model and compare in-sample accuracy.\n\nbest_resamples &lt;- \n  bind_rows(\n            show_best(rf_tune, metric = \"accuracy\", n = 1) %&gt;% mutate(model = \"Random Forest\") %&gt;% select(model, accuracy = mean),  \n            show_best(knn_tune, metric = \"accuracy\", n = 1) %&gt;% mutate(model = \"K-NN\") %&gt;% select(model, accuracy = mean), \n            show_best(lasso_tune, metric = \"accuracy\", n = 1) %&gt;% mutate(model = \"Logistic Reg\") %&gt;% select(model, accuracy = mean), \n            show_best(boost_tune, metric = \"accuracy\", n = 1) %&gt;% mutate(model = \"Boosted Trees\") %&gt;% select(model, accuracy = mean)\n  )\n\nbest_resamples %&gt;% \n  arrange(desc(accuracy)) %&gt;% \n  knitr::kable()\n\nWe can see that the random forests, K-NN, and boosted trees models perform exceptionally on the resamples of the train data, while even the best lasso logistic regression model performs much worse than the other three. However, there is high chance that our models have overfit on the training data and actually will not perform as well when generalizing to new data. This is where out-of-sample data comes to play, as we will use the portion of the data we set aside at the beginning to calculate accuracy on new data.\n\n\nOut-of-sample Accuracy\nNow that we have a set of hyperparameters that optimize performance for each model, we can update our workflows, fit them on the entirety of the training set and perform predictions on the test set. Since the test set is part of our initial data set that we set aside, the classe variable is known and thus we can calculate accuracy. The LASSO logistic regression model probably will not be useful for prediction but for completeness I will calculate test set accuracy for all models.\n\n# Final Random Forests Workflow\n\nrf_best_accuracy &lt;- select_best(rf_tune, metric = \"accuracy\") # retain the values of the hyperparameters that optimize accuracy\nrf_wf_final &lt;- finalize_workflow(rf_wf, rf_best_accuracy) # and pass them on to the workflow\n\nset.seed(1209)\n\nrf_final_fit &lt;- last_fit(rf_wf_final, split) # use last_fit with the split object created at the start to fit the model on the training set and predict on the test set\n\n# Final KNN\n\nknn_best_accuracy &lt;- select_best(knn_tune, metric = \"accuracy\")\nknn_wf_final &lt;- finalize_workflow(knn_wf, knn_best_accuracy)\n\nset.seed(1387)\n\nknn_final_fit &lt;- last_fit(knn_wf_final, split) \n\n# LASSO\n\nlasso_best_accuracy &lt;- select_best(lasso_tune, metric = \"accuracy\")\nlasso_wf_final &lt;- finalize_workflow(lasso_wf, lasso_best_accuracy)\nlasso_final_fit &lt;- last_fit(lasso_wf_final, split) \n\n# Final Boosted Tree\n\nboost_best_accuracy &lt;- select_best(boost_tune, metric = \"accuracy\")\nboost_wf_final &lt;- finalize_workflow(boost_wf, boost_best_accuracy)\n\nset.seed(54678)\n\nboost_final_fit &lt;- last_fit(boost_wf_final, split)\n\n\nbest_oos &lt;- bind_rows(\n                      rf_final_fit %&gt;% mutate(model = \"Random Forest\"), \n                      knn_final_fit %&gt;% mutate(model = \"K-NN\"), \n                      lasso_final_fit %&gt;% mutate(model = \"LASSO LogReg\"), \n                      boost_final_fit %&gt;% mutate(model = \"Boosted Trees\")\n                      ) %&gt;% \n  select(model, .metrics) %&gt;% \n  unnest(cols = .metrics) %&gt;% \n  filter(.metric == \"accuracy\") %&gt;% \n  arrange(desc(.estimate))\n\nbest_oos %&gt;% knitr::kable()\n\nWe can see that the boosted trees and k nearest neighbours models perform great, with random forest trailing slightly behind. The LASSO logistic regression model has much lower performance and would not be preferred. At this point we could walk away with a model that has a 99.8% accuracy on unseen data. However, we can take it a couple of steps further to see if we can achieve even greater accuracy, as we’ll see in the next sections.\n\n\nEnsemble Model\nIn the previous section we used the tune package to try out different hyperparameter combinations over our data and estimate model accuracy using cross-validation. Let’s assume we haven’t yet tested the best model on our test data as we’re only supposed to use the test set for final selection and we shouldn’t be using the knowledge from applying to test data to improve performance. We can use the objects that were created with tune_grid to add the different model definitions to the model stack. Remember when we specified in the arguments that we save the predictions and workflows? This is because this information is required for this step, to combine the different models. Furthermore, the reason why we kept roc_auc as a metric while tuning is because it creates soft predictions, which are required in classification problems to create the stack. Since the outputs of these models will be highly correlated, the blend_predictions function performs regularization to decide which outputs will be used in the final prediction.\n\n# cl &lt;- makePSOCKcluster(5)\n# registerDoParallel(cl)\n\nset.seed(5523)\n\nmodel_stack &lt;- stacks() %&gt;% \n  add_candidates(rf_tune) %&gt;% \n  add_candidates(knn_tune) %&gt;%\n  add_candidates(lasso_tune) %&gt;%\n  add_candidates(boost_tune) %&gt;% \n  blend_predictions(metric = metric_set(accuracy))\n\nmodel_stack_fit &lt;- model_stack %&gt;% fit_members()\n\n# stack_pred_train &lt;- train %&gt;% \n#   bind_cols(., predict(model_stack_fit, new_data = ., type = \"class\"))\n\nstack_pred_test &lt;- test %&gt;% \n  bind_cols(., predict(model_stack_fit, new_data = ., type = \"class\"))\n\n# stopCluster(cl)\n\n\n# stack_pred_train %&gt;% accuracy(factor(classe), .pred_class)\nstack_pred_test %&gt;% \n  mutate(classe = factor(classe)) %&gt;% \n  accuracy(classe, .pred_class) %&gt;% \n  knitr::kable()\n\nWe see that in the end we achieved the same accuracy as our best model, which is not unexpected considering our accuracy was almost perfect. We can also have a look at the weights of the different models used in the ensemble.\n\nautoplot(model_stack_fit, type = \"weights\") %&gt;% \n  ggplotly()\n\n\nWe can see our ensemble assigned high weights to boost_tree models, you’ll need to zoom in to see the weights for other models.\n\nWhile there was not much room for improvement, as mentioned in the beginning, this was a good opportunity to play around with the new package in practice.\nAlthough this data set did not present much of a challenge in terms of predicting the outcome, we managed to cover many of the different steps in the modeling process using tidymodels. Further steps one could take in their analyses could potentially involve using functionality from the tidyposterior package to make statistical comparisons between the models we constructed that performed similarly. Finally, the tidymodels ecosystem of packages is constantly growing and as an example, parts of this process could be further simplified/combined using the new workflowsets package which became available on CRAN while I was working on this post."
  }
]